// SPDX-License-Identifier: MIT
pragma solidity ^0.8.12;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/// @title Lizard Token Vesting
contract LizardLaunchpad is Ownable, ReentrancyGuard {
    /// @notice Struct Stage is struct of vesting stages
    /// @notice Stage can be configured for different conditions, according to tokenomics
    struct Stage {
        uint index;
        bool registrationStarted;
        bool stageStarted;
        bool whitelist;
        bool sale;
        uint totalUsers;
        uint maxUsers;
        uint totalTokenAmount;
        uint userTokenAmount;
        uint percentTGE;
        uint percentLinear;
        uint firstClaimAmount;
        uint onePaymentAmount;
        uint startTime;
        uint paymentPeriod;
        uint totalPaymentPeriod;
        uint lockUpPeriod;
        bytes32 merkleRoot;
        mapping(address => bool) addressRegistered;
        mapping(address => uint) amountReceived;

        uint maxAmountForUser;
        mapping(address => uint) amountBought;
        mapping(address => uint) userBuyingTime;
    }

    mapping(uint => Stage) stages;
    mapping(address => bool) public blacklisted;

    uint lastStageIndex;

    IERC20 LizardToken;

    uint public publicSalePrice;
    uint public privateSalePrice;

    event Claim(uint index, address receiver, uint amount);
    event Registration(uint index, address user, bool whitelist);
    event PrivateSale(uint index, address user, uint amount, uint value);
    event PublicSale(uint index, address user, uint amount, uint value);

    constructor(address tokenAddress) {
        LizardToken = IERC20(tokenAddress);
    }

    /// @notice Modifiers

    /// @notice whenStageStarted checks stage has been started
    /// @param index is index of current stage
    modifier whenStageStarted(uint index) {
        require(stages[index].stageStarted, "Stage is't started");
        _;
    }

    /// @notice whenRegistrationStarted checks stage registration has been started
    /// @param index is index of current stage
    modifier whenRegistrationStarted(uint index) {
        require(stages[index].registrationStarted, "Registration is't started");
        _;
    }

    /// @notice indexIsCorrect checks index is correct
    /// @param index is index of current stage
    modifier indexIsCorrect(uint index) {
        require(index <= lastStageIndex, "Invalid index");
        _;
    }

    /// @notice userIsNotBlocked checks user is not in blacklist
    /// @param user is user address
    modifier userIsNotBlocked(address user) {
        require(!blacklisted[user], "Address in blacklist");
        _;
    }

    /// @notice User functions

    /// @notice stageRegistration allows users to register on stage without whitelist
    /// @param index is index of current stage
    function stageRegistration(uint index) external indexIsCorrect(index) whenRegistrationStarted(index) userIsNotBlocked(msg.sender) {
        require(!stages[index].whitelist, "Only by whitelist");
        require(!stages[index].addressRegistered[msg.sender], "Address registered");
        require(stages[index].totalUsers < stages[index].maxUsers || stages[index].maxUsers == 0, "Exceed max user amount");
        stages[index].totalUsers++;
        stages[index].addressRegistered[msg.sender] = true;

        emit Registration(index, msg.sender, false);
    }

    /// @notice stageRegistrationWL allows users to register on stage with whitelist
    /// @param index is index of current stage
    /// @param proof is proof the user is on the whitelist generated by MerkleTree library
    function stageRegistrationWL(uint index, bytes32[] calldata proof) external indexIsCorrect(index) whenRegistrationStarted(index) userIsNotBlocked(msg.sender) {
        require(checkInWhitelist(proof, index), "Address is not in the whitelist");
        require(!stages[index].addressRegistered[msg.sender], "Address registered");
        require(stages[index].totalUsers < stages[index].maxUsers || stages[index].maxUsers == 0, "Exceed max user amount");
        stages[index].totalUsers++;
        stages[index].addressRegistered[msg.sender] = true;

        emit Registration(index, msg.sender, true);
    }

    function privateSale(uint index, uint amount, bytes32[] calldata proof) external payable indexIsCorrect(index) whenStageStarted(index) nonReentrant userIsNotBlocked(msg.sender) {
        require(stages[index].sale, "It is not sale stage");
        require(checkInWhitelist(proof, index), "Address is not in the whitelist");
        require(msg.value >= privateSalePrice * amount, "Insufficient funds");
        require(stages[index].amountBought[msg.sender] + amount <= stages[index].maxAmountForUser || stages[index].maxAmountForUser == 0, "Exceed max allowed amount");

        address receiver = msg.sender;
        stages[index].amountBought[receiver] += amount;
        stages[index].userBuyingTime[receiver] = block.timestamp;
        stages[index].addressRegistered[receiver] = true;
        uint firstClaimAmount = (amount * stages[index].percentTGE) / 100;
        if (firstClaimAmount > 0) {
            stages[index].amountReceived[receiver] += firstClaimAmount;
            LizardToken.transfer(receiver, firstClaimAmount);
        }

        emit PrivateSale(index, msg.sender, amount, msg.value);
    }

    function publicSale(uint index, uint amount) external payable indexIsCorrect(index) whenStageStarted(index) nonReentrant userIsNotBlocked(msg.sender) {
        require(stages[index].sale, "It is not sale stage");
        require(msg.value >= publicSalePrice * amount, "Insufficient funds");
        address receiver = msg.sender;
        require(stages[index].amountBought[receiver] + amount <= stages[index].maxAmountForUser || stages[index].maxAmountForUser == 0, "Exceed max allowed amount");
        stages[index].amountBought[receiver] += amount;
        stages[index].userBuyingTime[receiver] = block.timestamp;
        stages[index].addressRegistered[receiver] = true;
        uint firstClaimAmount = (amount * stages[index].percentTGE) / 100;
        if (firstClaimAmount > 0) {
            stages[index].amountReceived[receiver] += firstClaimAmount;
            LizardToken.transfer(receiver, firstClaimAmount);
        }

        emit PublicSale(index, receiver, amount, msg.value);
    }

    /**
     * @notice claim allows users to get his tokens (according to stage conditional)
     *
     * The function takes into account all stages conditions of tokenomics
     * TGE, Lock Up, Linear
     * It  is designed in such a way that it checks all the necessary conditions to receive tokens
     * All data is specified in the Stage structure under the index [index], and must be correct
     *
     * @param index is index of current stage
     */
    function claim(uint index) external indexIsCorrect(index) whenStageStarted(index) nonReentrant userIsNotBlocked(msg.sender) {
        Stage storage _stage = stages[index];
        address payable receiver = payable(msg.sender);
        require(_stage.addressRegistered[receiver], "Address is not registered");
        uint amountForUser = _stage.userTokenAmount;
        uint onePaymentAmount = _stage.onePaymentAmount;
        uint startTime = _stage.startTime;
        uint firstClaimAmount = _stage.firstClaimAmount;
        if (_stage.sale) {
            amountForUser = _stage.amountBought[receiver];
            onePaymentAmount = (amountForUser * _stage.percentLinear) / 100;
            startTime = _stage.userBuyingTime[receiver];
            firstClaimAmount = (stages[index].amountBought[receiver] * stages[index].percentTGE) / 100;
        }
        require(_stage.amountReceived[receiver] < amountForUser, "You claimed all your tokens");
        if (_stage.firstClaimAmount <= _stage.amountReceived[receiver])
            require(checkLockUpPeriod(index), "Lock up period is active");
        uint claimsPassed = checkClaimsPassed(index);
        
        uint availableAmount = block.timestamp >= startTime + _stage.totalPaymentPeriod + _stage.lockUpPeriod ? 
        amountForUser - _stage.amountReceived[receiver] : 
        (onePaymentAmount * claimsPassed) + firstClaimAmount - _stage.amountReceived[receiver];
        require(availableAmount > 0, "Address do not have claimable tokens");
        _stage.amountReceived[receiver] += availableAmount;
        LizardToken.transfer(receiver, availableAmount);

        emit Claim(index, receiver, availableAmount);
    }

    /// @notice Admin functions

    /**
     * @notice airdrop allows the owner to airdrop tokens with current stage contditions
     * !Carefully, a large fee is possible
     *
     * @param amount is amount of tokens defined to each user
     * @param to is array of addresses
     * @param index is index of stage for airdrop
     */
    function airdrop(uint256 amount, address[] calldata to, uint index) public onlyOwner {
        require(!stages[index].sale, "Airdrop on sale stage not allowed");
        require(to.length <= stages[index].maxUsers, "Exceeded max user amount");
        require(amount * to.length <= stages[index].totalTokenAmount, "Exceeded max token amount");

        stages[index].stageStarted = true;
        stages[index].userTokenAmount = amount;
        uint onePaymentAmount = (amount * stages[index].percentLinear) / 100;
        stages[index].onePaymentAmount = onePaymentAmount;
        stages[index].startTime = block.timestamp;
        stages[index].totalUsers = to.length;
        uint dropAmount = (amount * stages[index].percentTGE) / 100;
        stages[index].firstClaimAmount = dropAmount;

        for (uint i = 0; i < to.length; i++) {
            stages[index].addressRegistered[to[i]] = true;
            stages[index].amountReceived[to[i]] = dropAmount;
            if (dropAmount > 0)
                LizardToken.transfer(to[i], dropAmount);
        }
    }

    /**
     * @notice adminRegistration allows the owner to register an indefinite number of addresses per stage
     * !Carefully, a large fee is possible
     *
     * @param index is index of current stage
     * @param userAddress is array of addresses
     */
    function adminRegistration(uint index, address[] calldata userAddress) external indexIsCorrect(index) whenRegistrationStarted(index) onlyOwner {
        require(!stages[index].sale, "Sale stage: admin registration not allowed");
        require(stages[index].totalUsers + userAddress.length <= stages[index].maxUsers, "User limit exceeded");
        stages[index].totalUsers += userAddress.length;
        for (uint i = 0; i < userAddress.length; i++) {
            stages[index].addressRegistered[userAddress[i]] = true;
        }
    }

    /**
     * @notice newStage allows the owner to add new stage with any conditionals
     *
     * @param whitelist is the state checks using of whitelist. Set true if you are
     * @param sale is the state checks stage is sale type stage
     * @param maxUsers is the maximum number of users that can be registered at the stage
     * @param totalTokenAmount is the amount of tokens intended for this stage
     * @param percentTGE is the percent of tokens (of totalTokenAmount), wich will be available to get, immediately after the start of the stage (set to 0 if not needed)
     * @param totalPaymentPeriod is the period (month, some days, etc.) after which a full tokens will be unlocked (set in UNIX time)
     * @param paymentPeriod is the time period (month, some days, etc.) after which a new portion of tokens will be unlocked in linear vesting (set in UNIX time)
     * @param lockUpPeriod is the time period (month, some days, etc.) during which the tokens will be frozen on the contract (set in UNIX time) (set to 0 if not needed)
     * @param maxAmountForUser is max user amount allowed to take part in the stage (set to 0 if not needed)
     * @param merkleRoot is the merkle root hash of whitelist, generated vy MerkleTree library (set 0x0000000000000000000000000000000000000000000000000000000000000000 if not needed)
     */
    function newStage(
        bool whitelist,
        bool sale,
        uint maxUsers,
        uint totalTokenAmount,
        uint percentTGE,
        uint totalPaymentPeriod,
        uint paymentPeriod,
        uint lockUpPeriod,
        uint maxAmountForUser,
        bytes32 merkleRoot
    ) external onlyOwner {
        require(totalPaymentPeriod >= paymentPeriod, "Invalid period values");
        lastStageIndex++;
        stages[lastStageIndex].index = lastStageIndex;
        stages[lastStageIndex].whitelist = whitelist;
        stages[lastStageIndex].sale = sale;
        stages[lastStageIndex].maxUsers = maxUsers;
        stages[lastStageIndex].totalTokenAmount = totalTokenAmount;
        stages[lastStageIndex].percentTGE = percentTGE;
        stages[lastStageIndex].percentLinear = (100 - percentTGE) / (totalPaymentPeriod / paymentPeriod);
        stages[lastStageIndex].totalPaymentPeriod = totalPaymentPeriod;
        stages[lastStageIndex].paymentPeriod = paymentPeriod;
        stages[lastStageIndex].lockUpPeriod = lockUpPeriod;
        stages[lastStageIndex].maxAmountForUser = maxAmountForUser;
        stages[lastStageIndex].merkleRoot = merkleRoot;
    }

    ///@notice changeStageSettings allows to change multiple settings in current stage
    function changeStageSettings(
        uint index,
        bool whitelist,
        bool sale,
        uint maxUsers,
        uint totalTokenAmount,
        uint percentTGE,
        uint totalPaymentPeriod,
        uint percentLinear,
        uint paymentPeriod,
        uint lockUpPeriod,
        bytes32 merkleRoot
    ) external onlyOwner indexIsCorrect(index) {
        require(!stages[index].stageStarted, "Started stage can't be changed");
        require(totalPaymentPeriod >= paymentPeriod, "Invalid period values");
        stages[index].whitelist = whitelist;
        stages[index].sale = sale;
        stages[index].maxUsers = maxUsers;
        stages[index].totalTokenAmount = totalTokenAmount;
        stages[index].percentTGE = percentTGE;
        stages[lastStageIndex].percentLinear = (100 - percentTGE) / (totalPaymentPeriod / paymentPeriod);
        stages[index].totalPaymentPeriod = totalPaymentPeriod;
        stages[index].percentLinear = percentLinear;
        stages[index].paymentPeriod = paymentPeriod;
        stages[index].lockUpPeriod = lockUpPeriod;
        stages[index].merkleRoot = merkleRoot;
    }

    /// @notice toggleRegistrationState allows to change registration state
    /// @param index is index of current stage
    function toggleRegistrationState(uint index) external onlyOwner indexIsCorrect(index) {
        stages[index].registrationStarted = !stages[index].registrationStarted;
    }

    /**
     * @notice toggleStageState allows to change stage state
     * The function count and set userTokenAmount, onePaymentAmount and firstClaimAmount
     * After set stageStarted to true, start lock up and linear timers, and users can get first claim if TGE percent is not 0
     *
     * @param index is index of current stage
     */
    function toggleStageState(uint index) external onlyOwner indexIsCorrect(index) {
        if (!stages[index].stageStarted && !stages[index].sale) {
            stages[index].registrationStarted = false;

            uint userTokenAmount = stages[index].totalTokenAmount / stages[index].totalUsers;
            stages[index].userTokenAmount = userTokenAmount;

            uint onePaymentAmount = (userTokenAmount * stages[index].percentLinear) / 100;
            stages[index].onePaymentAmount = onePaymentAmount;

            uint firstClaimAmount = (userTokenAmount * stages[index].percentTGE) / 100;
            stages[index].firstClaimAmount = firstClaimAmount;

            stages[index].startTime = block.timestamp;
        }
        stages[index].stageStarted = !stages[index].stageStarted;
    }

    ///@notice setBlackList allows admin to add and to delete address to blacklist (repeated function call to the same address to remove it from blacklist)
    ///@param user is user address
    function setBlacklist(address user) external onlyOwner {
        blacklisted[user] = !blacklisted[user];
    }

    ///@notice setPublicSalePrice allows admin to set Price for public sale
    ///@param _price is new price
    function setPublicSalePrice(uint _price) external onlyOwner {
        publicSalePrice = _price;
    }

    ///@notice setPrivateSalePrice allows admin to set Price for private sale
    ///@param _price is new price
    function setPrivateSalePrice(uint _price) external onlyOwner {
        privateSalePrice = _price;
    }

    /// @notice withdrawAll allows the owner to withdraw the entire balance of the contract
    function withdrawAll() public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "Insufficent balance");
        _widthdraw(owner(), address(this).balance);
    }

    /// @notice withdrawPart allows the owner to withdraw a specified amount from the contract balance
    /// @param amount is the amount to withdraw
    function withdrawPart(uint256 amount) public onlyOwner {
        uint256 balance = address(this).balance;
        require(balance > 0, "Insufficent balance");
        _widthdraw(owner(), amount);
    }

    /// @notice _widthdraw is a private function that handles the actual transfer of Ether
    /// @param _address is the address to send the Ether to
    /// @param _amount is the amount of Ether to send
    function _widthdraw(address _address, uint256 _amount) private {
        (bool success, ) = _address.call{ value: _amount }("");
        require(success, "Failed to widthdraw Ether");
    }

    ///@notice Read functions

    function getStage(uint index) external view returns (
            bool whitelist,
            bool sale,
            uint maxUsers,
            uint totalTokenAmount,
            uint percentTGE,
            uint percentLinear,
            uint startTime,
            uint paymentPeriod,
            uint totalPaymentPeriod,
            uint lockUpPeriod,
            uint maxAmountForUser,
            bytes32 merkleRoot
        )
    {
        uint _index = index;
        return (
            stages[_index].whitelist,
            stages[_index].sale,
            stages[_index].maxUsers,
            stages[_index].totalTokenAmount,
            stages[_index].percentTGE,
            stages[_index].percentLinear,
            stages[_index].startTime,
            stages[_index].paymentPeriod,
            stages[_index].totalPaymentPeriod,
            stages[_index].lockUpPeriod,
            stages[_index].maxAmountForUser,
            stages[_index].merkleRoot
        );
    }

    function getUserIsRegistered(uint index, address user) external view returns (bool) {
        return stages[index].addressRegistered[user];
    }

    function getUserAvailableAmount(uint index, address user) external view returns (uint) {
        Stage storage _stage = stages[index];
        require(_stage.addressRegistered[user], "Address is not registered");
        uint amountForUser = _stage.userTokenAmount;
        uint onePaymentAmount = _stage.onePaymentAmount;
        uint startTime = _stage.startTime;
        uint firstClaimAmount = _stage.firstClaimAmount;
        if (_stage.sale) {
            amountForUser = _stage.amountBought[user];
            onePaymentAmount = (amountForUser * _stage.percentLinear) / 100;
            startTime = _stage.userBuyingTime[user];
            firstClaimAmount = (stages[index].amountBought[user] * stages[index].percentTGE) / 100;
        }
        uint claimsPassed = checkClaimsPassed(index);
        
        uint availableAmount = block.timestamp >= startTime + _stage.totalPaymentPeriod + _stage.lockUpPeriod ? 
        amountForUser - _stage.amountReceived[user] : 
        (onePaymentAmount * claimsPassed) + firstClaimAmount - _stage.amountReceived[user];
        return availableAmount;
    }

    function getUserNextUnlockTime(uint index, address user) external view returns (uint) {
        Stage storage _stage = stages[index];
        require(_stage.addressRegistered[user], "Address is not registered");
        uint startTime = _stage.sale ? _stage.userBuyingTime[user] : _stage.startTime;
        require(block.timestamp >= startTime + _stage.totalPaymentPeriod + _stage.lockUpPeriod, "All payments is unlocked");
        uint claimPassed = checkClaimsPassed(index);
        uint nextUnlockTime = startTime + _stage.lockUpPeriod + (_stage.paymentPeriod * (claimPassed + 1));
        return nextUnlockTime;
    }

    function getUserReceivedAmount(uint index, address user) external view returns (uint) {
        return stages[index].amountReceived[user];
    }

    function getUserBoughtAmount(uint index, address user) external view returns (uint) {
        return stages[index].amountBought[user];
    }

    /// @notice Internal check functions

    /// @notice checkClaimsPassed counts current the number of payments to be paid at the moment to user, excluding the first payment
    /// @param index is index of current stage
    function checkClaimsPassed(uint index) internal view returns (uint) {
        uint startTime = stages[index].sale ? stages[index].userBuyingTime[msg.sender] : stages[index].startTime;
        uint claimPassed = block.timestamp - startTime >= stages[index].lockUpPeriod  ? (block.timestamp - (startTime + stages[index].lockUpPeriod)) / stages[index].paymentPeriod : 0;
        return claimPassed;
    }

    /// @notice checkLockUpPeriod checks lock up period ended or not
    /// @param index is index of current stage
    function checkLockUpPeriod(uint index) internal view returns (bool) {
        uint startTime = stages[index].sale ? stages[index].userBuyingTime[msg.sender] : stages[index].startTime;
        bool unlocked = stages[index].lockUpPeriod != 0 ? block.timestamp > startTime + stages[index].lockUpPeriod : true;
        return (unlocked);
    }

    /// @notice checkInWhitelist check address in whitelist
    /// @param proof is the user is on the whitelist generated by MerkleTree library
    /// @param index is index of current stage
    function checkInWhitelist(bytes32[] calldata proof, uint index) internal view returns (bool) {
        bytes32 leaf = keccak256(abi.encode(msg.sender));
        bool verified = MerkleProof.verify(proof, stages[index].merkleRoot, leaf);
        return verified;
    }
}
